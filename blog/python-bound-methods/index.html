<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<link rel="stylesheet" href="../../css/base.css" type="text/css">
		<link rel="stylesheet" href="../../css/blog.css" type="text/css">
		<link rel="stylesheet" href="../../highlight/styles/default.css">
		<link rel="stylesheet" href="../../highlight/styles/monokai.css">
		<script src="../../highlight/highlight.pack.js"></script>
		<script>
function highlight() { // highlight all code blocks using HighlightJS
	var code_blocks = document.getElementsByTagName("code");
	for (var i = 0; i < code_blocks.length; i++)
		hljs.highlightBlock(code_blocks[i]);
}
		</script>
		<title>Blog - Python Gotchas: Bound Methods | Anthony Zhang</title>
	</head>
	<body onload="highlight()">
		<h1>Hi, I'm <a href="/">Anthony Zhang</a>.</h1>
		<ul class="site_links">
			<li><a href="/blog/" class="page">blog</a></li>
			<span class="divider"></span>
			<li><a href="http://uberi.github.io/University-Notes" class="page">notes</a></li>
			<span class="divider"></span>
			<li><a href="/Résumé.pdf" class="page">résumé</a></li>
			<span class="divider"></span>
			<li><a href="https://github.com/Uberi" class="contact">github</a></li>
			<span class="divider"></span>
			<li><a href="http://www.linkedin.com/pub/anthony-zhang/8b/aa5/7aa" class="contact">linkedin</a></li>
			<span class="divider"></span>
			<li><a href="mailto:azhang9@gmail.com" class="contact">email</a></li>
			<span class="divider"></span>
			<li><a href="https://www.facebook.com/anthony.zhang.user" class="contact">facebook</a></li>
			<span class="divider"></span>
			<li><a href="http://uberi.mesecons.net/">mesecons</a></li>
			<span class="divider"></span>
			<li><a href="http://www.autohotkey.net/~Uberi/">autohotkey.net</a></li>
		</ul>
		<div class="post">
			<h2>Python Gotchas: Bound Methods</h2>
			<p class="time">April 5, 2015</p>
			<p>I've seen this one a few times now, and apparently it's a pretty common mistake to make. Consider the following:</p>
			<pre><code class="python">class A:
    def x(self): print(self)

def f(callback):
    callback("hello")

a = A()</code></pre>
			<p>Now, assuming we've run this code, what's the difference between <code class="python">f(a.x)</code> and <code class="python">f(A.x)</code>?</p>
			<p>If you're used to languages like Javascript (or other languages with prototypal OOP), then you'd probably expect that the <code class="python">x</code> method print out <code class="python">"hello"</code> in both cases - that methods act like functions with a <code class="python">self</code> parameter when separated from their class.</p>
			<p>This is not the case - the first snippet will actually result in an error! The difference becomes immediately obvious when we check the types of these two:</p>
			<pre><code class="python">&gt;&gt;&gt; A.x
&lt;unbound method A.x&gt;
&gt;&gt;&gt; a.x
&lt;bound method A.x of &lt;__main__.A instance at 0x4f698e2b2370&gt;&gt;</code></pre>
			<p>Most Pythoners have seen issues caused by something like what's described in <a href="http://stackoverflow.com/questions/114214">this StackOverFlow answer</a>. This is because calls like <code class="python">a.x()</code> are actually translated into something similar to <code class="python">A.x(a)</code>.</p>
			<p>However, this translation is <b>actually applied to method accesses, not method calls</b>. Anytime we access a method of an object using something like <code class="python">a.x</code>, its first parameter actually gets bound to the object's instance!</p>
			<p>In other words, <code class="python">a.x</code> gets translated into something like <code class="python">(lambda *args, **kwargs: A.x(a, *args, **kwargs))</code> - the method is partially applied to its associated class instance. This is called a <b>bound method</b>. Note that given this transformation <code class="python">a.x()</code> is equivalent to <code class="python">(lambda *args, **kwargs: A.x(a, *args, **kwargs))()</code>.</p>
			<p>This difference becomes very important when we're doing things like using methods as callbacks. In the first example, we made things work by just accessing the method through the class itself in order to get the unbound version. This works, but is definitely not best practice - it's easy to mix up bound and unbound versions of the method.</p>
			<p>The correct thing to do is to use the <code class="python">@staticmethod</code> decorator on our callback, which eliminates its <code class="python">self</code> parameter entirely and means that we can sidestep the whole bound/unbound distinction entirely:</p>
			<pre><code class="python">class A:
    @staticmethod
    def x(stuff): print(stuff)

def f(callback):
    callback("hello")

f(A.x)
</code></pre>
			<p>Note that if we used the <code class="python">@classmethod</code> decorator to make <code class="python">x</code> a class method, <code class="python">A.x</code> would also bind <code class="python">A</code> to the first parameter of <code class="python">x</code>. In other words, when we access class methods, their first parameters are bound to their classes.</p>
			<div class="closing">Questions or comments? Drop me a line at <a href="mailto:azhang9@gmail.com?subject=Blog:%20Lecture%20Notes">azhang9@gmail.com</a>.</div>
		</div>
		<div class="license">
			<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" /></a> This work by <a xmlns:cc="http://creativecommons.org/ns#" href="https://uberi.github.io/" property="cc:attributionName" rel="cc:attributionURL">Anthony Zhang</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
			Copyright 2013-2015 Anthony Zhang.
		</div>
	</body>
</html>
